h1. classy_enum

ClassyEnum is a Ruby on Rails gem that adds class-based enumerator functionality to ActiveRecord attributes.

h2. Requirements

*Rails:* Any version of Rails 2.3.x or Rails 3.x. (Older versions of Rails may work, but have not been tested)

*Ruby:* Ruby 1.8.7 and 1.9.2.

h2. Installation

The gem is hosted at "rubygems.org":https://rubygems.org/gems/classy_enum and can be installed with: @gem install classy_enum@

h2. Example Usage

The most common use for ClassyEnum is to replace database lookup tables where the content and behavior is mostly static and has multiple "types". In this example, I have an ActiveRecord model called @Alarm@ with an attribute called @priority@. Priority is stored as a string (VARCHAR) type in the database and is converted to an enum value when requested. 

h2. 1. Generate the enum

The fastest way to get up and running with ClassyEnum is to use the built-in Rails generator like so:

Rails 2.3.x:

<pre>
script/generate classy_enum Priority low medium high
</pre>

Rails 3.x

<pre>
rails g classy_enum Priority low medium high
</pre>

A new file will be created at app/enums/priority.rb that will look like:

<pre>
class Priority < ClassyEnum::Base
  enum_classes :low, :medium, :high
end

class PriorityLow < Priority
end

class PriorityMedium < Priority
end

class PriorityHigh < Priority
end
</pre>

That is the default setup, but can be changed to fit your needs, like so...

Using the @enum_classes@ method, I have defined three priority levels: low, medium, and high. Each priority level can have different properties and methods associated with it. In my example, each enum class has a method called @send_email?@. By default this method returns false, but is overridden for high priority alarms and returns true.

Note: Defining the subclasses within your enum file is only required when you will be overriding behavior and/or properties. The member subclasses still exist without being defined here because ClassyEnum automatically creates a class for each member. The generator only creates these subclass definitions for convencience, but they can be deleted as shown in the following context.

<pre>
class Priority < ClassyEnum::Base
  enum_classes :low, :medium, :high

  def send_email?
    false
  end
end

class PriorityHigh < Priority
  def send_email?
    true
  end
end
</pre>

h2. Define the model

Your model needs a text field that will store a string representing the enum member. An example model schema might look something like:

<pre>
create_table "alarms", :force => true do |t|
  t.string   "priority"
end
</pre>

Then in my ActiveRecord model, Alarm, I've added a line that calls @classy_enum_attr@ with a single argument representing the enum I want to associate with my model. I am also delegating the send_email? method to my Priority enum class.

<pre>
class Alarm < ActiveRecord::Base
  classy_enum_attr :priority

  delegate :send_email?, :to => :priority
end
</pre>

With this setup, I can now do the following:

<pre>
@alarm = Alarm.create(:priority => :medium)

@alarm.priority  # => PriorityMedium

@alarm.send_email? # => false

@alarm.priority = :high

@alarm.send_email? # => true
</pre>

h2. Formtastic Support

To add ClassyEnum support to Formtastic, add the following to your formtastic.rb initializer (config/initializers/formtastic.rb):

<pre>
Formtastic::SemanticFormHelper.builder = ClassyEnum::SemanticFormBuilder
</pre>

Then in your Formtastic view forms, use this syntax: @<%= f.input :priority, :as => :enum_select %>@

h2. Notes

An ActiveRecord validator @validates_inclusion_of :field, :in => ENUM.all, :allow_nil => true@ is automatically added to your model when you use @classy_enum_attr@. 

h2. Copyright

Copyright (c) 2011 Peter Brown. See LICENSE for details.
